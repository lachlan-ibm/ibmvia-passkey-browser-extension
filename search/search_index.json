{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IBM Passkey Extension Documentation","text":"<p>Welcome to the docs for the IBM passkey extension. This is an open-source project which aims to provide passkey support to major vendors such as chromium, firefox and webkit. This browser extension also aims to provide developers/technical sales a tool for demonstrating passkey functionality without using hardware based security keys.</p> <p>To get started, you are encouraged to install from source:</p> <pre><code>git clone https://github.com/lachlan-ibm/ibm-security-passkey-extension.git\ncd ibm-security-passkey-extension\n</code></pre> <p>In the root directory run the build command. As there are variations in configuration files, adding the browser option will generate the appropriate build artefacts for each vendor. If no argument is passed, the default is chrome. Once you have generated the build directory containing the browser specific artefacts, you need to install the extension on your browser.</p>"},{"location":"#chrome-installation","title":"Chrome Installation","text":"<pre><code>bash buildScript.sh -b chrome\n</code></pre> <p>For chrome, there are several installation methods. Ideally, the extension should be distributed via officially supported distribution mechanisms.</p> <ul> <li>Chrome Web Store</li> <li>Self-hosting</li> </ul> <p>However, as this tool is still in development, it can be tested by loading an unpacked version. In this case, see Chrome Tutorial for instructions on how to load an unpacked extension. Choose the build directory as the extension directory.</p>"},{"location":"#firefox-installation","title":"Firefox Installation","text":"<pre><code>bash buildScript.sh -b firefox\n</code></pre> <p>See the Firefox Tutorial and refer to the install section for steps on how to install on firefox, or use the web-ext tool to run the extension from the command line. Furtermore, firefox provides the ability to load a zipped version of the extension as well, which is located the dist directory which is one of the artefacts generated after running the build command.</p> <p>After you have installed the ibm passkey extension, try the Quickstart Guide.</p>"},{"location":"d/","title":"Publishing your site","text":"<p>The great thing about hosting project documentation in a <code>git</code> repository is the ability to deploy it automatically when new changes are pushed. MkDocs makes this ridiculously simple.</p>"},{"location":"d/#github-pages","title":"GitHub Pages","text":"<p>If you're already hosting your code on GitHub, GitHub Pages is certainly the most convenient way to publish your project documentation. It's free of charge and pretty easy to set up.</p>"},{"location":"d/#with-github-actions","title":"with GitHub Actions","text":"<p>Using GitHub Actions you can automate the deployment of your project documentation. At the root of your repository, create a new GitHub Actions workflow, e.g. <code>.github/workflows/ci.yml</code>, and copy and paste the following contents:</p> Material for MkDocsInsiders <pre><code>name: ci # (1)!\non:\n  push:\n    branches:\n      - master # (2)!\n      - main\npermissions:\n  contents: write\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Configure Git Credentials\n        run: |\n          git config user.name github-actions[bot]\n          git config user.email 41898282+github-actions[bot]@users.noreply.github.com\n      - uses: actions/setup-python@v5\n        with:\n          python-version: 3.x\n      - run: echo \"cache_id=$(date --utc '+%V')\" &gt;&gt; $GITHUB_ENV # (3)!\n      - uses: actions/cache@v4\n        with:\n          key: mkdocs-material-${{ env.cache_id }}\n          path: .cache\n          restore-keys: |\n            mkdocs-material-\n      - run: pip install mkdocs-material # (4)!\n      - run: mkdocs gh-deploy --force\n</code></pre> <ol> <li> <p>You can change the name to your liking.</p> </li> <li> <p>At some point, GitHub renamed <code>master</code> to <code>main</code>. If your default branch     is named <code>master</code>, you can safely remove <code>main</code>, vice versa.</p> </li> <li> <p>Store the <code>cache_id</code> environmental variable to access it later during cache     <code>key</code> creation. The name is case-sensitive, so be sure to align it with <code>${{ env.cache_id }}</code>.</p> <ul> <li>The <code>--utc</code> option makes sure that each workflow runner uses the same time zone.</li> <li>The <code>%V</code> format assures a cache update once a week.</li> <li>You can change the format to <code>%F</code> to have daily cache updates.</li> </ul> <p>You can read the manual page to learn more about the formatting options of the <code>date</code> command.</p> </li> <li> <p>This is the place to install further MkDocs plugins or Markdown     extensions with <code>pip</code> to be used during the build:</p> <pre><code>pip install \\\n  mkdocs-material \\\n  mkdocs-awesome-pages-plugin \\\n  ...\n</code></pre> </li> </ol> <pre><code>name: ci\non:\n  push:\n    branches:\n      - master\n      - main\npermissions:\n  contents: write\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    if: github.event.repository.fork == false\n    steps:\n      - uses: actions/checkout@v4\n      - name: Configure Git Credentials\n        run: |\n          git config user.name github-actions[bot]\n          git config user.email 41898282+github-actions[bot]@users.noreply.github.com\n      - uses: actions/setup-python@v5\n        with:\n          python-version: 3.x\n      - run: echo \"cache_id=$(date --utc '+%V')\" &gt;&gt; $GITHUB_ENV\n      - uses: actions/cache@v4\n        with:\n          key: mkdocs-material-${{ env.cache_id }}\n          path: .cache\n          restore-keys: |\n            mkdocs-material-\n      - run: apt-get install pngquant # (1)!\n      - run: pip install git+https://${GH_TOKEN}@github.com/squidfunk/mkdocs-material-insiders.git\n      - run: mkdocs gh-deploy --force\nenv:\n  GH_TOKEN: ${{ secrets.GH_TOKEN }} # (2)!\n</code></pre> <ol> <li> <p>This step is only necessary if you want to use the     built-in optimize plugin to automatically compress images.</p> </li> <li> <p>Remember to set the <code>GH_TOKEN</code> repository secret to the value of your     personal access token when deploying Insiders, which can be done     using GitHub secrets.</p> </li> </ol> <p>Now, when a new commit is pushed to either the <code>master</code> or <code>main</code> branches, the static site is automatically built and deployed. Push your changes to see the workflow in action.</p> <p>If the GitHub Page doesn't show up after a few minutes, go to the settings of your repository and ensure that the publishing source branch for your GitHub Page is set to <code>gh-pages</code>.</p> <p>Your documentation should shortly appear at <code>&lt;username&gt;.github.io/&lt;repository&gt;</code>.</p>"},{"location":"d/#with-mkdocs","title":"with MkDocs","text":"<p>If you prefer to deploy your project documentation manually, you can just invoke the following command from the directory containing the <code>mkdocs.yml</code> file:</p> <pre><code>mkdocs gh-deploy --force\n</code></pre> <p>This will build your documentation and deploy it to a branch <code>gh-pages</code> in your repository. See this overview in the MkDocs documentation for more information. For a description of the arguments, see the documentation for the command.</p>"},{"location":"d/#gitlab-pages","title":"GitLab Pages","text":"<p>If you're hosting your code on GitLab, deploying to GitLab Pages can be done by using the GitLab CI task runner. At the root of your repository, create a task definition named <code>.gitlab-ci.yml</code> and copy and paste the following contents:</p> Material for MkDocsInsiders <pre><code>pages:\n  stage: deploy\n  image: python:latest\n  script:\n    - pip install mkdocs-material\n    - mkdocs build --site-dir public\n  artifacts:\n    paths:\n      - public\n  rules:\n    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'\n</code></pre> <pre><code>pages:\n  stage: deploy\n  image: python:latest\n  script: # (1)!\n    - pip install git+https://${GH_TOKEN}@github.com/squidfunk/mkdocs-material-insiders.git\n    - mkdocs build --site-dir public\n  artifacts:\n    paths:\n      - public\n  rules:\n    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'\n</code></pre> <ol> <li>Remember to set the <code>GH_TOKEN</code> repository secret to the value of your     personal access token when deploying Insiders, which can be done     using masked custom variables.</li> </ol> <p>Now, when a new commit is pushed to the default branch (typically <code>master</code> or <code>main</code>), the static site is automatically built and deployed. Commit and push the file to your repository to see the workflow in action.</p> <p>Your documentation should shortly appear at <code>&lt;username&gt;.gitlab.io/&lt;repository&gt;</code>.</p>"},{"location":"d/#other","title":"Other","text":"<p>Since we can't cover all possible platforms, we rely on community contributed guides that explain how to deploy websites built with Material for MkDocs to other providers:</p>   - [:material-microsoft-azure-devops: Azure][Azure] - [:simple-cloudflarepages: Cloudflare Pages][Cloudflare Pages] - [:simple-digitalocean: DigitalOcean][DigitalOcean] - [:material-airballoon-outline: Fly.io][Flyio] - [:simple-netlify: Netlify][Netlify] - [:simple-vercel: Vercel][Vercel] - [:simple-codeberg: Codeberg Pages][Codeberg Pages]"},{"location":"developers/","title":"Developer","text":""},{"location":"developers/#software-design-architecutre","title":"Software Design Architecutre","text":"<p>The architecture of the extension is structured to handle FIDO2 registration and authentication efficiently across multiple contexts. Below is a visual representation of how the service worker, content scripts, and message-passing mechanisms work together to ensure smooth communication and functionality.</p> <p></p> <p>As shown in the diagram, the service worker handles background tasks, while the content scripts interact with the webpage's DOM and facilitate data exchange between the extension and the relying party.</p>"},{"location":"developers/#differences-between-chrome-and-firefox-manifest-files","title":"Differences Between Chrome and Firefox Manifest Files","text":"<p>The initial step in building a browser extension is defining its configuration through the manifest.json file. Every extension requires this file in its root directory, which outlines key details about the extension\u2019s structure and behavior. It serves as a blueprint, describing the features and capabilities the extension can support.</p> ChromeFirefox <pre><code>\"manifest_version\": 3,\n\"name\": \"IBM Passkey Extension\",\n\"version\": \"1.0\",\n\n\"description\": \"Performs FIDO2 registration and authentication ceremonies\",\n\"homepage_url\": \"https://github.com/sramsamy/fido2-browser-extension\",\n\"icons\": {\n    \"48\": \"icons/ibm-cloud--hyper-protect-crypto-services-48x48.png\",\n    \"96\": \"icons/ibm-cloud--hyper-protect-crypto-services-96x96.png\"\n},\n\n\"permissions\": [\"activeTab\", \"storage\", \"sidePanel\", \"notifications\"],\n\"side_panel\": {\n    \"default_path\": \"side_panel.html\"\n},\n\n\"action\": {\n    \"default_icon\": \"icons/ibm-cloud--hyper-protect-crypto-services-48x48.png\",\n    \"default_title\": \"FIDO2\"\n},\n\"background\": {\n    \"service_worker\": \"background_script.js\"\n},\n\n\"content_scripts\": [\n    {\n        \"matches\": [\"https://*/*\"],\n        \"js\": [\"main.js\"],\n        \"world\": \"MAIN\",\n        \"run_at\": \"document_start\"\n    },\n    {\n        \"matches\": [\"https://*/*\"],\n        \"js\": [\"middle.js\"],\n        \"run_at\": \"document_start\"\n    }\n],\n\"externally_connectable\": {\n    \"matches\": [\"https://*/*\"]\n}\n</code></pre> <pre><code>\"manifest_version\": 3,\n\"name\": \"IBM Passkey Extension\",\n\"version\": \"1.0\",\n\"description\": \"Performs FIDO2 registration and authentication ceremonies\",\n\"homepage_url\": \"https://github.com/sramsamy/fido2-browser-extension\",\n\"icons\": {\n    \"48\": \"icons/ibm-cloud--hyper-protect-crypto-services-48x48.png\",\n    \"96\": \"icons/ibm-cloud--hyper-protect-crypto-services-96x96.png\"\n},\n\n\"permissions\": [\"activeTab\", \"storage\", \"notifications\", \"scripting\", \"tabs\"],\n\"sidebar_action\": {\n    \"default_icon\": {\n        \"48\": \"icons/ibm-cloud--hyper-protect-crypto-services-48x48.png\",\n        \"96\": \"icons/ibm-cloud--hyper-protect-crypto-services-96x96.png\"\n    },\n    \"default_title\": \"\",\n    \"default_panel\": \"side_panel.html\",\n    \"open_at_install\": false\n},\n\n\"action\": {\n    \"default_icon\": \"icons/ibm-cloud--hyper-protect-crypto-services-48x48.png\",\n    \"default_title\": \"Open Sidebar\"\n},\n\"background\": {\n    \"scripts\": [\"background_script.js\"]\n},\n\n\"content_scripts\": [\n    {\n        \"matches\": [\"&lt;all_urls&gt;\"],\n        \"js\": [\"main.js\"],\n        \"world\": \"MAIN\",\n        \"run_at\": \"document_start\",\n        \"all_frames\": true\n    },\n    {\n        \"matches\": [\"&lt;all_urls&gt;\"],\n        \"js\": [\"middle.js\"],\n        \"run_at\": \"document_start\"\n    }\n],\n\"content_security_policy\": {\n    \"extension_pages\": \"script-src 'self' 'wasm-unsafe-eval'; object-src 'self'\"\n},\n\n\"host_permissions\": [\"https://*/*\", \"http://*/*\"],\n\"web_accessible_resources\": [\n    {\n        \"resources\": [\"main.js\"],\n        \"matches\": [\"&lt;all_urls&gt;\"]\n    }\n]\n</code></pre>"},{"location":"developers/#service-worker","title":"Service Worker","text":"<p>The service worker operates in a special context known as the background page, which provides access to a <code>window</code> global object and standard DOM APIs. Additionally, it can access any WebExtension APIs. However, service workers cannot directly interact with web pages. Instead, communication between the service worker and content scripts is done through a message-passing API.</p> <p>For more details on service workers, refer to the MDN Web Docs on Background Scripts.</p> <p>In this extension, the service worker is crucial as it generates attestation keys for various attestation types. Currently, only the <code>none</code> attestation type is supported. In the future, the extension will support <code>fido-u2f</code>, <code>packed</code>, <code>tpm</code>, and <code>packed-self</code> attestation types. The service worker handles all requests for attestation keys, set in the <code>fidoUtilsConfig</code> object, from content scripts, relying on message-passing for communication.</p>"},{"location":"developers/#content-scripts","title":"Content Scripts","text":"<p>Content scripts execute in a special environment known as an <code>isolated world</code>, allowing them to interact with the DOM of the relying party's webpage but preventing direct access to any JavaScript variables or functions created by the webpage.</p> <p>To bypass this limitation, the extension uses two content scripts:</p> <ol> <li><code>main.js</code> runs in the \"MAIN\" world, meaning it shares the same execution environment as the relying party's JavaScript. This allows it to interact with the page\u2019s JavaScript, but at the cost of losing access to WebExtension APIs such as <code>browser.runtime</code>.</li> <li><code>middle.js</code>, on the other hand, remains in the default <code>`\"ISOLATED\"</code> world, acting as a bridge between <code>main.js</code> and the service worker.</li> </ol>"},{"location":"developers/#communication-between-scripts","title":"Communication Between Scripts","text":"<p>To facilitate communication between these scripts, the extension uses two message-passing methods:</p> <ul> <li> <p>Custom Events: Since <code>main.js</code> and <code>middle.js</code> both share the DOM, they communicate via custom events using JavaScript\u2019s <code>CustomEvent</code> interface. For example, when a user clicks the register button, it intercepts <code>navigator.credentials.create</code> and triggers a custom method. This method retrieves the <code>fidoUtilsConfig</code> object from the background service, passing it from the service worker to <code>middle.js</code> and finally to <code>main.js</code>.</p> </li> <li> <p>Message Passing: For communication between <code>middle.js</code> and the service worker, the extension relies on the WebExtension and Chrome message-passing API to relay requests and responses between the scripts.</p> </li> </ul> <p>To manage the differences between the Chrome and Firefox browser APIs, the extension uses an abstraction class called <code>BrowserApi</code>. This class helps streamline the interactions with the distinct APIs provided by Chrome and Firefox, allowing the extension to work across both browsers without duplicating code.</p> middle.js<pre><code>class BrowserApi {\n    static isChromeApi = navigator.userAgent.includes(\"Chrome\");\n    static isFirefoxApi = navigator.userAgent.includes(\"Firefox\");\n\n    static get runtime() {\n        return this.isChromeApi ? chrome.runtime : browser.runtime;\n    }\n\n    static get sidePanel() {\n        if (this.isChromeApi) {\n            return chrome.sidePanel;\n        } else if (this.isFirefoxApi) {\n            return browser.sidebarAction;\n        }\n        return null;\n    }\n}\n</code></pre> <p>This setup ensures efficient communication between all parts of the extension, allowing it to handle FIDO2 registration and authentication operations.</p>"},{"location":"developers/#dispatching-a-custom-event","title":"Dispatching a Custom Event","text":""},{"location":"developers/#dispatching-a-custom-event_1","title":"Dispatching a Custom Event","text":"<p>Since <code>main.js</code> loses access to the Browsers <code>runtime</code> API, Custom events are a handy way to communicate between different components of the extension, especially when dealing with message-passing between content scripts and background scripts. In our extension, we use the <code>CustomEvent</code> interface to dispatch events containing specific messages or data.</p> <p>The first step is to dispatch a <code>CustomEvent</code> containing the necessary message. This method is used in several places, including the <code>requestFidoUtilsConfig()</code> function, which requests the FIDO2 configuration from the background script.</p> main.js<pre><code>document.dispatchEvent(\n    new CustomEvent(\"requestFidoUtilsConfig\", {\n        detail: {\n            title: \"getFidoUtils\",\n            message: \"Retrieve fidoutilsConfig variable\",\n        },\n    })\n);\n</code></pre> <p><code>middle.js</code> then listens for the event dispatched from main.js and communicates with the background service worker using the browser.runtime API.</p> middle.js<pre><code>document.addEventListener(\"requestFidoUtilsConfig\", async function (e) {\n    let data = e.detail;\n    const response = await BrowserApi.runtime.sendMessage({\n        message: \"Retrieve fidoutilsConfig variable\",\n    });\n</code></pre> <p>The background service worker listens for incoming messages from the content scripts. Upon receiving a request, it retrieves the fidoutilsConfig object and sends it back to <code>middle.js</code> through a callback function. The following code snippet demonstrates this process:</p> background_script.js<pre><code>fido.BrowserApi.runtime.onMessage.addListener(\n    function (request, sender, sendResponse) {\n        if (request.message === \"Retrieve fidoutilsConfig variable\") {\n            console.log(\"Received request for the fidoutilsConfig object\");\n            const config = getFidoUtilsConfig();\n            sendResponse({ result: config });\n            return true;\n        }\n    }\n);\n</code></pre> <p>After receiving the response from the background script, middle.js dispatches a custom event to main.js. This custom event contains the fidoutilsConfig object within the CustomEvent.detail property.</p> middle.js<pre><code>document.dispatchEvent(\n    new CustomEvent(\"setFidoUtilsConfig\", {\n        detail: {\n            title: \"Response\",\n            message: \"Sending fidoutilsConfig to main.js\",\n            response: response,\n        },\n    })\n);\n</code></pre> <p>In the requestFidoUtilsConfig function within main.js, an event listener is set up to listen for responses from middle.js. This function returns a promise that, when fulfilled, sets the fidoutilsConfig variable with the object received from middle.js.</p> middle.js<pre><code>function handleConfigResponse(e) {\n    if (e.detail &amp;&amp; e.detail.response.result) {\n        resolve(e.detail.response.result);\n    } else {\n        reject(\"Failed to retrieve fidoutilsConfig\");\n    }\n    document.removeEventListener(\"setFidoUtilsConfig\", handleConfigResponse);\n}\n</code></pre>"},{"location":"developers/#fido2-config","title":"FIDO2 Config","text":"<p>Upon installing the extension for this first time, an adaption of Shane Weedens <code>fido2-node-client</code> script, which can be viewed here, generates a set of attestation keys for various attestation types are generated with various cryptographic keys and certificates that are essential for FIDO2 attestation. The extension creates a self-signed Certificate Authority (CA) and signs certificates for different attestation types Additionally, it outputs a JSON configuration parameter that is essential for this extension, enabling it to perform FIDO2 registration and authentication ceremonies.</p> <p>The different attestation types include:</p> <ul> <li><code>U2F</code></li> <li><code>Packed</code></li> <li><code>Packed-self</code></li> <li><code>TPM</code></li> </ul> <p>This code snippet below checks if a U2F attestation key already exists in the storage. If it doesn't, it creates a new key pair using the <code>jsrasign</code> library and converts the public and private keys to PEM format, storing the private key for future use.</p> <pre><code>let u2fPublicKeyPEM = null;\nlet u2fPrivateKeyPEM = null;\nif (!store[U2F_ATTESTATION_KEY]) {\n    console.log(\"Creating U2F key: \" + U2F_ATTESTATION_KEY);\n    let kp = jsrsasign.KEYUTIL.generateKeypair(\"EC\", \"secp256r1\");\n    u2fPublicKeyPEM = jsrsasign.KEYUTIL.getPEM(kp.pubKeyObj, \"PKCS8PUB\");\n    u2fPrivateKeyPEM = jsrsasign.KEYUTIL.getPEM(kp.prvKeyObj, \"PKCS8PRV\");\n    store[U2F_ATTESTATION_KEY] = u2fPrivateKeyPEM;\n} else {\n    // Retrieve the existing U2F private key PEM and extract the public key\n    u2fPrivateKeyPEM = store[U2F_ATTESTATION_KEY];\n    let prvKey = jsrsasign.KEYUTIL.getKey(u2fPrivateKeyPEM);\n    u2fPublicKeyPEM = fidoutils.certToPEM(\n        jsrsasign.b64toBA(jsrsasign.hextob64(prvKey.pubKeyHex))\n    );\n}\n</code></pre> <p>Attestation is optional in FIDO authentication, and currently this extension is defaulted to <code>packed-self</code> when a user generates a passkey. Future versions of the IBM passkey extension should add support for other formats to meet the FIDO Alliance's Metadata Service (MDS) and provide proof that the authenticator meets the RP's criteria. For more information on FIDO attestation, see this FIDO White Paper.</p> <p>An example of the <code>FIDO2_CONFIG</code> object:</p> <pre><code>let exampleConfig = {\n    encryptionPassphrase: \"MySecret\",\n\n    origin: \"https://example.ibm.com:9443\",\n\n    \"fido-u2f\": {\n        privateKeyHex:\n            \"00b8464b082d2a77bae48d8ec84694cd4cca7b41948635622a8db1bc87a8894f17\",\n        publicKeyHex:\n            \"04ffd1d9a70f7c1c83fa8660925dfbfcbb4d1c232e5443f5d9ee4ad72480fec9d20068c05b5d7777cc25fd27d93015c0ea2d72f51d8eae1970729b98609a5013db\",\n        cert: \"MIIDFjCB/wIJAKiWRVc805iDMA0GCSqGSIb3DQEBCwUAMDExCzAJBgNVBAYTAlVTMQ0wCwYDVQQKDAROSVNUMRMwEQYDVQQDDApVSUNDUm9vdENBMB4XDTE5MDgwNzIwMjgwM1oXDTQ2MTIyMjIwMjgwM1owNTELMAkGA1UEBhMCVVMxDTALBgNVBAoMBE5JU1QxFzAVBgNVBAMMDlVJQ0NVMkYtU0lHTkVSMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE/9HZpw98HIP6hmCSXfv8u00cIy5UQ/XZ7krXJID+ydIAaMBbXXd3zCX9J9kwFcDqLXL1HY6uGXBym5hgmlAT2zANBgkqhkiG9w0BAQsFAAOCAgEAKP/Ck24JM+8J7Ns4g5a8XczXPPnYe+FFs7bUQoam2sEEPBzapdIssl9rYkFKvxIW8zgPHJVIQJ3hMmq9tGkhKXT+WzIew+BJRzBYscytaaqMURHuqM1usBFQZSBUYIlDCQqezxG9bZ4cx8gzmL4ldYPGwSAex3K9XOVdyNn+ut8/axcfhDYfr0zW498KOg1L72kjthiNTrJWGaCwkfCsNNtBHWy2HmGzAgMLi7Wn3eNzTyrbzj7GBBsFm6Nv5LKLxCwX8YEd6UWzYLuP/AhAG1+w1rfPmbdi0/hXGUr8h51dlTF2DUrxQfZvECA5Du4TZHHKpTu7opI2BSVabXYp+F25RbkcE1oAqjrZeMdeWXFu5bcD5MvQ6Q3D/M1H1ngahFLzyzPprZ1OO5codyiRwhPtSyeR+FIi7yj9Lirxhv+t1pzm9N6z8DEW3Iman5+x+hGPP01n0RFP1H+Fu0jUCZfcZmx0ecrrd2r3B0YpyUR5n45dweBw+dyQZaPm0eenyMYFNuXWNx+aT7wcYFYhoYEqi0n7bGmvR3ZmFws3rBi2uLOamM1cOSnabOQ7Tvirq39TAbJ3dNZAwoD7pFn4YZHeywPGlENnij1bMnTYyVXRr/coi84bD4S147Ydm6lWpMcolpVlplbXJ3S3BDu/AqJGBqQwKtBUDuL0BbnbE+0=\",\n    },\n\n    packed: {\n        aaguid: \"37c4c2cf41544c5791039c9bdcca5b2b\",\n        privateKeyHex:\n            \"03e158d202854c3bc0cb233a726f4445b41b4ca80b370a2c30d8fe039f820d42\",\n        publicKeyHex:\n            \"045c6c82d6b47e2971a78ebbe8dd910ebbdcecb902019e6b37f743374c5740d9f0533068c562ebd7c11e55258b235efc48aba0d77f6d0ebe6f991321976ea1e072\",\n        cert: \"MIIDVTCCAT2gAwIBAgIJAKiWRVc805iEMA0GCSqGSIb3DQEBCwUAMDExCzAJBgNVBAYTAlVTMQ0wCwYDVQQKDAROSVNUMRMwEQYDVQQDDApVSUNDUm9vdENBMB4XDTE5MDgwNzIwMjgwM1oXDTQ2MTIyMjIwMjgwM1owXDELMAkGA1UEBhMCVVMxDTALBgNVBAoMBE5JU1QxIjAgBgNVBAsMGUF1dGhlbnRpY2F0b3IgQXR0ZXN0YXRpb24xGjAYBgNVBAMMEVVJQ0NQQUNLRUQtU0lHTkVSMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEXGyC1rR+KXGnjrvo3ZEOu9zsuQIBnms390M3TFdA2fBTMGjFYuvXwR5VJYsjXvxIq6DXf20Ovm+ZEyGXbqHgcqMQMA4wDAYDVR0TAQH/BAIwADANBgkqhkiG9w0BAQsFAAOCAgEAtsJl2cVtuRJqwm0SXhP2vGU3An79GxT1appa9JKLWz7iv5zOVWowKvbEnB6sqjNPZ1p65yEi5UmRNnkE6m6IFSRijz5eeWOHQ0ceQN4BhH9veE4Xe3WiOaahTTJX+hqj+5ByMhgw0dZ6+1iEu20BE0zKAA+VSrpA5O+LPOBDNjCfVzLI566ykNqe2mShm+UGNDYkTxVJmFXY9qyy/zLazynroE6qnIt03UutzifAnNNnBKqk9gK9C6cosDHeyvRGy9um1P21EC85yEZvN8wngzNmc8TJwnkXYHP4METHbjR9bmQP60e19a7so9sz7P5MhkFJ/JOURkbWh6qmzIGQhoNpGw6OQnAxHvkPiw9HuDEfjzIFX1LQi74uMIEG7juCIt2u56dXG7T0NM8MfVlupDJzi4AnwI+NuONrKtC5iK6HHSrRxCQ8QiPTemlymPhC/XMJW70PqDiH7cEmCbsDKg9cTN8mWCNNyb1/WkcfrP2zq+jm1Lp8Viam5kHsd66X9VP/44Aj5G6TGJU7ZitBB/hHqz0jznuZU+fRuGf2taQdCP/DXps/VngXrcvs4sRS3aid0KO5eLkUP8e11r909DMTvV/CsqghqXpS13oUbTs8cD12y93EftSbw6OKR30xcV1PScCOY/CSnCuSQFlgrXW1OotzmWQUKKKUB9Egzb8=\",\n    },\n\n    \"packed-self\": {\n        aaguid: \"1811ec8b8a91459299f217f35d53242e\",\n    },\n};\n</code></pre>"},{"location":"developers/#registering-a-credential","title":"Registering a Credential","text":"<p>The IBM passkey extension works by overriding the relying party's call to navigator.credentials.create(), a method from the WebAuthn API. This API, developed by W3C and FIDO, enables servers to use public key cryptography for FIDO2 registration and authentication.</p> <p>When a user registers an authenticator, the server provides data that binds the user to a credential (a public-private key pair) along with identifying information. The extension intercepts the original navigator.credentials.create method using a reference to the original methods and then calls a custom implementation to handle the registration process.</p> main.js<pre><code>let myCredentials = {\n    create: navigator.credentials.create.bind(navigator.credentials),\n    get: navigator.credentials.get.bind(navigator.credentials),\n};\n</code></pre> <p>The <code>createMethod</code> function is a custom implementation of <code>navigator.credentials.create()</code>, which is used to register new FIDO2 passkeys. When called, this method receives an <code>options</code> object, which contains data provided by the server to create a new credential for the user. This data includes:</p> <ul> <li>Challenge: A cryptographically random buffer generated by the server.</li> <li>Relying Party (rp) Object: Contains information about the server requesting the credential.</li> <li>User Object: Identifies the user for whom the credential is being created.</li> <li>PubKeyCredParams: Describes the cryptographic algorithms supported by the server.</li> <li>Authenticator Selection: Defines requirements for the authenticator type.</li> <li>Attestation Data: Optionally includes evidence of the authenticator\u2019s trustworthiness.</li> </ul> main.js<pre><code>async function createMethod(options) {\n    console.log(\"options object: \", options);\n    try {\n        const userPresence = await userPresenceModal(\n            \"Would you like to create a new passkey?\"\n        );\n        console.log(\"user presence\", userPresence);\n        let oldFidoUtilsConfig = fido.getFidoUtilsConfig();\n        let newFidoutilsConfig = await requestFidoUtilsConfig();\n        // Set the origin in the config\n        newFidoutilsConfig[\"origin\"] = window.location.origin;\n        // Set the fidoUtilsConfig object with the new one retrieved from the background script\n        fido.setFidoUtilsConfig(newFidoutilsConfig);\n\n        if (\"publicKey\" in options) {\n            // Normalise the challenge field of the input to Uint8Array\n            if (options.publicKey.challenge instanceof ArrayBuffer) {\n                console.log(\"find me array buffer\");\n                options.publicKey.challenge = new Uint8Array(\n                    options.publicKey.challenge\n                );\n                console.log(\"new normalised challenge is\", options.publicKey.challenge);\n            }\n            if (userPresence) {\n                const result = await fido.processCredentialCreationOptions(\n                    options,\n                    \"packed-self\"\n                );\n                let publicCred = result.spkc;\n\n                publicCred[\"getClientExtensionResults\"] = function () {\n                    return {};\n                };\n                publicCred[\"toJSON\"] = function () {\n                    return result;\n                };\n\n                publicCred.rawId = fido.base64toBA(\n                    fido.base64utobase64(publicCred.rawId)\n                );\n\n                publicCred.response.attestationObject = fido.base64toBA(\n                    fido.base64utobase64(publicCred.response.attestationObject)\n                );\n\n                publicCred.response.clientDataJSON = fido.base64toBA(\n                    fido.base64utobase64(publicCred.response.clientDataJSON)\n                );\n\n                showSuccessModal(\n                    \"Custom create method successful. Creating new credential.\"\n                );\n                await new Promise((resolve) =&gt; setTimeout(resolve, 3000));\n                return await publicCred;\n            } else {\n                return await myCredentials.create(options);\n            }\n            // else fallback to original create method\n        } else {\n            return await myCredentials.create(options);\n        }\n    } catch (error) {\n        console.error(\"Error creating credential:\", error);\n        throw error;\n    }\n}\n</code></pre> <p>The method starts by checking whether the <code>challenge</code> in the <code>options</code> object is in the correct format. If the <code>challenge</code> is an <code>ArrayBuffer</code>, it is normalised into a <code>Uint8Array</code> to ensure proper handling during the credential creation process. The function then presents a user presence modal to request consent from the user to create a passkey. Once consent is granted, the function processes the credential creation options by invoking <code>fido.processCredentialCreationOptions</code>, which prepares a FIDO2 server public key credential. The resulting object contains the <code>publicKey</code>, which is used in future authentication, as well as other fields such as the <code>rawID</code>, <code>attestationObject</code>, and <code>clientDataJSON</code>. These fields provide cryptographic evidence of the registration.</p> publicKeyCredentialCreationOptions object<pre><code>{\n    \"publicKey\": {\n        \"rp\": {\n            \"id\": \"fidointerop.securitypoc.com\",\n            \"name\": \"fidointerop.securitypoc.com\"\n        },\n        \"user\": {\n            \"id\": {\n                \"0\": 185 ...\n            },\n            \"name\": \"Sachin Ramsamy\",\n            \"displayName\": \"Sachin Ramsamy\"\n        },\n        \"timeout\": 300000,\n        \"challenge\": {\n            \"0\": 54 ...\n        },\n        \"excludeCredentials\": [\n            {\n                \"id\": {\n                    \"0\": 197 ...\n                },\n                \"type\": \"public-key\"\n            }\n        ],\n        \"extensions\": {},\n        \"authenticatorSelection\": {\n            \"requireResidentKey\": true,\n            \"userVerification\": \"preferred\"\n        },\n        \"attestation\": \"direct\",\n        \"pubKeyCredParams\": [\n            {\n                \"alg\": -7,\n                \"type\": \"public-key\"\n            }\n        ]\n    }\n}\n</code></pre> <p>Finally, the credential object is returned, with the necessary attributes for validating the registration, including methods to convert the object into a JSON format or retrieve client extension results. The server will then validate the credential by parsing the attestation object, client data JSON, and authenticator data. It will also ensure that the challenge matches the one originally sent and that the origin set in the extension matches the expected origin. This process ensures the integrity of the FIDO2 registration ceremony and verifies the authenticity of the newly created credential.</p> <p>The publicKeyObject retrieved at the end is encoded using COSE, a compact format that describes the credential's public key and its associated metadata.</p> main.js | Weeden, S (2024) fido2-node-client [Source code] https://github.com/sbweeden/fido2-node-clients/blob/main/fidoutils.js<pre><code>let credPublicKeyCOSE = {\n    1: 2, // kty\n    3: -7, // alg\n    \"-1\": 1, // crv\n    \"-2\": jsrsasign.b64toBA(\n        jsrsasign.hextob64(keypair.pubKeyObj.getPublicKeyXYHex()[\"x\"])\n    ), // xCoordinate\n    \"-3\": jsrsasign.b64toBA(\n        jsrsasign.hextob64(keypair.pubKeyObj.getPublicKeyXYHex()[\"y\"])\n    ), // yCoordinate\n};\n</code></pre> <p>If the validation process is successful, the server stores the publicKeyBytes and credentialId in a database, linking them to the user's account. If the custom create implemention fails, then the extension will fall back to the original <code>navigator.credentials.create()</code> method.</p>"},{"location":"developers/#authenticating-with-an-ibm-passkey-extension-credential","title":"Authenticating with an IBM Passkey Extension Credential","text":"<p>After completing the registration step, the credential can be used to authenticate the user. During authentication, an assertion is created to prove that the user owns the private key associated with their registered credential. The extension overrides the original <code>navigator.credentials.get()</code> method, preparing a FIDO2 <code>ServerAuthenticatorAssertionResponse</code> to serve as the parameters for the WebAuthn call. This custom method works by utlising one of Shane's <code>fido2-node-client</code> methods, <code>fido.processCredentialRequestOptions()</code>.</p> publicKeyCredential object<pre><code>{\n    \"publicKey\": {\n        \"rpId\": \"fidointerop.securitypoc.com\",\n        \"timeout\": 300000,\n        \"challenge\": {\n            \"0\": 28 ...\n                },\n                \"type\": \"public-key\"\n            }\n        ],\n        \"extensions\": {\n            \"devicePubKey\": {\n                \"attestation\": \"direct\"\n            }\n        }\n    }\n</code></pre> <p>The server generates a cryptographically random challenge, while the allowCredentials array specifies which credentials the server wants the user to authenticate with. The assertion object returned by the custom <code>get()</code> method is also a <code>publicKeyCredential</code> object but differs from the registration version. Instead of including the public key, it includes a signature. The <code>id</code> and <code>rawId</code> fields identify the credential used in the authentication, while <code>authenticatorData</code> contains information similar to registration data but without the public key. This data is also used to generate the signature. The <code>clientDataJSON</code> contains data passed from the browser to the authenticator, and this too is used in the signature generation process. The signature itself is generated by the private key tied to the credential, with the <code>fido.processCredentialRequestOptions()</code> method resolving the private key using the credential ID.</p> serverPublicKeyCredential object<pre><code>{\n    \"id\": \"U2FsdGVkX1_ymEkaxY69SeqRX1CPyA6abYNyenPDY-UWpmKOyXKx24K7buq-M_o8cfDYgROHcXQ7jEnMFpgCxtyquPjPYiQ3EyQc0aEC-QJVVC7BVYkT89fz9buA3mOe\",\n    \"rawId\": [\n        83 ..\n    ],\n    \"response\": {\n        \"clientDataJSON\": [\n            123 ..\n        ],\n        \"authenticatorData\": [\n            246 ..\n        ],\n        \"signature\": [\n            48 ...\n        ],\n        \"userHandle\": \"\"\n    },\n    \"type\": \"public-key\"\n}\n</code></pre> <p>In the extensions custom <code>get()</code> method, the server generates a challenge, and the method normalises this and other credential options (like <code>allowCredentials</code>) into <code>Uint8Array</code> format if they are of type <code>ArrayBuffer</code>. If the user consents to authenticate via the IBM passkey extension, the method uses fido.processCredentialRequestOptions() to create a serverPublicKeyCredential. The returned credential is formatted, converting fields like <code>authenticatorData</code>, <code>clientDataJSON</code>, <code>signature</code>, and <code>rawId</code> into binary form using <code>fido.base64toBA()</code>.</p> main.js<pre><code>async function myGetMethod(options) {\n    try {\n        const userPresence = await userPresenceModal(\n            \"Would you like to authenticate using the ibm passkey extension?\"\n        );\n        if (\"credentials\" in navigator) {\n            console.log(\"navigator.credentials\", navigator.credentials);\n            let fidoutilsConfigVariable = await requestFidoUtilsConfig();\n            fidoutilsConfigVariable[\"origin\"] = window.location.origin;\n            fido.setFidoUtilsConfig(fidoutilsConfigVariable);\n            if (options.publicKey.challenge instanceof ArrayBuffer) {\n                options.publicKey.challenge = new Uint8Array(\n                    options.publicKey.challenge\n                );\n            }\n\n            if (options.publicKey.allowCredentials instanceof Array) {\n                console.log(\"options.publicKey.allowCredentials is instanceof Array\");\n                for (let i = 0; i &lt; options.publicKey.allowCredentials.length; i++) {\n                    // Normalise to Uint8Array if id is of type ArrayBuffer\n                    if (options.publicKey.allowCredentials[i].id instanceof ArrayBuffer) {\n                        options.publicKey.allowCredentials[i].id = new Uint8Array(\n                            options.publicKey.allowCredentials[i].id\n                        );\n                    }\n                }\n            } else {\n                console.log(\"error detected in allowedCred data type\");\n            }\n            if (userPresence) {\n                if (fido.canAuthenticateWithCredId(options)) {\n                    const result = await fido.processCredentialRequestOptions(options);\n                    let serverPublicKeyCredential = result;\n                    serverPublicKeyCredential[\"getClientExtensionResults\"] = function () {\n                        return {};\n                    };\n                    serverPublicKeyCredential.response.authenticatorData =\n                        fido.base64toBA(\n                            fido.base64utobase64(\n                                serverPublicKeyCredential.response.authenticatorData\n                            )\n                        );\n                    serverPublicKeyCredential.response.clientDataJSON = fido.base64toBA(\n                        fido.base64utobase64(\n                            serverPublicKeyCredential.response.clientDataJSON\n                        )\n                    );\n                    serverPublicKeyCredential.response.signature = fido.base64toBA(\n                        fido.base64utobase64(serverPublicKeyCredential.response.signature)\n                    );\n                    serverPublicKeyCredential.rawId = fido.base64toBA(\n                        fido.base64utobase64(serverPublicKeyCredential.rawId)\n                    );\n                    return await serverPublicKeyCredential;\n                } else {\n                    return await myCredentials.get(options);\n                }\n            } else {\n                return await myCredentials.get(options);\n            }\n        }\n    } catch (error) {\n        console.error(\"IBM Passkey Extension error\", error);\n        return await myCredentials.get(options);\n    }\n}\n</code></pre> <p>If authentication succeeds, a success modal is displayed, and the processed credential is returned. If authentication fails or the user presence check is not met, the function falls back to the original <code>navigator.credentials.get()</code> method to attempt standard authentication.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#chrome","title":"Chrome","text":"<p>Once you have successfuly installed the extension on your chrome browser, you should see it listed under the 'All extensions' section.</p> <p></p> <p>Click on the <code>details</code> button and toggle the option to pin the extension to your chrome toolbar - this will make opening the sidebar easier by clicking on the icon.</p> <p></p> <p>Open the side panel to view by clicking on the extensions icon in your google chrome toolbar.</p> <p></p>"},{"location":"quickstart/#firefox","title":"Firefox","text":"<p>On firefox, navigate to <code>about:debugging</code> and click on This Firefox on the left side of the webpage.</p> <p></p> <p>Then click on the extensions icon in the firefox toolbar and pin the IBM passkey extension to your toolbar.</p> <p></p> <p>Now you an toggle to the sidebar by clicking the icon in your toolbar.</p> <p></p>"},{"location":"quickstart/#interacting-with-the-side-panel","title":"Interacting with the Side Panel","text":"<p>Once the side panel is open, you will see the <code>FIDO2 Config</code> button.</p> <p></p> <p>Click this button to display the FIDO2 config object.</p> <p>The FIDO2 config object contains attestation keys for various attestation types that the extension supports. This configuration allows you to manage the different key pairs used in FIDO2 operations.</p> <p></p> <p>You can modify various parameters within the FIDO2 config object. After making your changes, click the <code>Update</code> button located below the FIDO2 object.</p> <p>This action will update the FIDO2 object with your new values. Upon successful update, a success message will be displayed.</p> <p></p>"},{"location":"quickstart/#creating-a-passkey","title":"Creating a Passkey","text":"<p>Navigate to a webpage that supports WebAuthn registration and authentication ceremonies such as:</p> <ul> <li>WebAuthn.io</li> <li>webauthn.dodo.dev</li> <li>token2</li> </ul> <p>Additionally, if you have access to w3id on IBM Security Verify, you can test the extension against a demonstration site managed by IBMer, Shane Weeden.</p> <p>Look for the <code>Register</code> button on the demo site. Click on it to initiate the creation of a passkey credential.</p> <p>When prompted, you will see a user presence modal asking you to confirm the registration. Click Yes to proceed with creating the passkey.</p> <p></p> <p>Congratulations! You have created your first FIDO2 Passkey credential with the IBM Passkey Extension!</p> <p></p> <p>After successfully creating a passkey, you can use it for authentication.</p>"},{"location":"quickstart/#authentication","title":"Authentication","text":"<p>This process may differ depending on the demo site you're using. Some may support multiple credentials with data persistence, while others may be simpler without it.</p> <p>Locate the credential you created during the registration step if required. Otherwise, directly click the Authenticate button after registering a passkey to test the extension's authentication capabilities.</p> <p>A confirmation modal will appear, asking whether you'd like to proceed with the authentication attempt.</p> <p></p> <p>Click <code>Yes</code>.</p> <p>You should see a success modal indicating that the extension's authentication method was successful.</p> <p></p> <p>Congratulations! You've now successfully registered and authenticated a FIDO2 passkey using the IBM Passkey Extension!</p>"},{"location":"quickstart/#exportimport","title":"Export/Import","text":"<p>Supported on relying parties that allow multiple registrations, such as the demonstration site used in this quickstart guide.</p> <p>You can export your credential via the sidebar if you haven't done so already, and then try switching to a different browser (e.g., from Chrome to Firefox) to test the export/import feature. This feature enables recovery of a registration from a credential ID and CA certificate.</p> <p>After clicking the <code>FIDO2 Config</code> button in the side panel, you will see the <code>Export</code> button at the bottom of the side panel window.</p> <p></p> <p>Click <code>Yes</code> when prompted to export your credential.</p> <p></p> <p>Choose a location on your local machine to save your credential.</p> <p>In a different browser, load the extension, navigate to fidointerop.com and open the Registrations page.</p> <p>Open the side panel and click the Import button to load the credential exported in the previous step.</p> <p></p> <p>Keep in mind that new attestation keys are created with every install of the extension, which is why you exported the credential earlier. Once imported, click the Update button to save your changes.</p> <p></p> <p>Locate the Authenticate button for the credential you created in the previous section and test it.</p> <p></p> <p>Awesome! You've now demonstrated a cross-browser registration.</p>"}]}